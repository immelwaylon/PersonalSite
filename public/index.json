
[{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" Extended Summary # I created a python program that takes user mouse input and manipulates it to scaled generate piecewise functions in order to optomize graph war gaming.\nBelow is a video showing graphwar gameplay for reference. Credit to hueyfragic for the video. Your browser doesn\u0026rsquo;t support HTML5 video. The Basic Concept # The line generation works by a simple concept. If you offset two abs functions (one inverted) by making it abs(x+1)-abs(x), it will make a portion of the line sloped, while the rest remains flat. This means we can add these functions to make a line have whatever slopes we want on whatever intervals. Here is a desmos graph that demonstrates the concept between -1 and 1. We can use this to automate the generation of a line that goes through all the points that we specify. Normally, we would have to shift the line up or down, referencing something like a y intercept. However, the line in graph war always comes from a character, so we on\u0026rsquo;t even have to set a y offset to go through the points we want. The relative slopes are all we need.\nMy Process # Programmed a line generation script, tested with set points in desmos Programmed a script to take mouse inputs based on terminal-printed instructions Programmed a script to convert mouse(screen location) inputs to cartesian coordinates. I implemented an extra script to offset y values by a negligible amount if they overlapped, so a real line would be generated going roughly through every user-inputted point. Integrated each function together for a final working script I rewrote the entire thing from scratch 3-4 times trying to get it all working.\nFinal Code # GitHub\nWebsite Codeblock #Import libraries import time from threading import Thread from pynput.mouse import Listener, Button #Initialize global variables global pixelList, corner1, corner2, rounding #Setting Variables clickTime = 30 #Default 30 xScale = 25 #Default 25 yScale = 15 #Default 15 rounding = 2 #Default 2 ##---------------------------------------------Get user input---------------------------------------------## #Initialize variables pixelList = [] corner1 = [] corner2 = [] #Get user input def mouse_input(): global corner1, corner2 keepCorner=False if (not(corner1 == [] and corner2 ==[])): if (input (\u0026#34;Pertain corner values? (y/n) \u0026#34;) == \u0026#34;y\u0026#34;): keepCorner=True else: keepCorner=False corner1 = [] corner2 = [] #Wait for user start input(\u0026#34;Enter anything to start\u0026#34;) if (keepCorner): print(\u0026#34;\\nClick pixel points\u0026#34;) else: print(\u0026#34;\\nClick the top left corner\u0026#34;) # Take click readings for \u0026lt;clickTime\u0026gt; seconds def on_click(x, y, button, pressed): #Bring global variables global pixelList, corner1, corner2 # Check if the left button was pressed if pressed and button == Button.left: #Input corner values if not already if ((corner1 == []) and (keepCorner == False)): corner1 = (x,y) print(\u0026#34;Click the bottom right corner\u0026#34;) elif ((corner2 == []) and (keepCorner == False)): corner2 = (x,y) print(\u0026#34;Click pixel points\u0026#34;) #Input main list values else: pixelList.append((x,y)) # Initialize the Listener to monitor mouse clicks with Listener(on_click=on_click) as listener: #Thread to count \u0026lt;clickTime\u0026gt; seconds while listener is running def time_out(period_sec: int): time.sleep(period_sec) #Stop the listener listener.stop() Thread(target=time_out, args=(clickTime,)).start() listener.join() ##---------------------------------------------Convert user input to scaled coordinates---------------------------------------------## #Modifies pixel point values to fit a specified cartesian plane def translate_points(xScale, yScale, corner1, corner2): #Initialize variables global pixelList width = corner2[0] - corner1[0] height = corner2[1] - corner1[1] finalList = [] i = 0 #Translate points to a scaled cartesian plane while (i\u0026lt;len(pixelList)): #Translate points modX = (pixelList[i][0]-((corner1[0]+corner2[0])/2)) modY = ((pixelList[i][1]-((corner1[1]+corner2[1])/2)) * -1) #Scale points modX *= (2*xScale)/width modY *= (2*yScale)/height finalList.append((modX, modY)) i += 1 return finalList #Fix X coordinate repitition def discontinuity_fix(list): discontinuity = True while discontinuity == True: discontinuity = False i=1 while i\u0026lt;((len(list))): if list[i-1][0] == list[i][0]: list[i] = (list[i][0] + (10**(-rounding)), list[i][1]) discontinuity = True i += 1 list.sort() return list ##---------------------------------------------Convert points to line and print---------------------------------------------## #Output ABS function piecewise line def output_abs_line(locations): xList = [] yList = [] for location in (locations): xList.append(location[0]) yList.append(location[1]) slopeList = [0]*(len(xList)) #Find all slopes for i in range (len(xList)-1): slopeList[i] = ((yList[i]-yList[i+1]) / (xList[i] - xList[i+1])) #Print equation of line going through points for i in range (len(xList)-1): slope = slopeList[i] x = xList[i] x2 = xList[i+1] if (slope\u0026lt;=0): print (\u0026#34;+ ((abs(\u0026#34; + str(round((slope), rounding)) + \u0026#34;x +\u0026#34; + str(round(x2*(abs(slope)), rounding)) + \u0026#34;)-abs(\u0026#34; + str(round((slope), rounding)) + \u0026#34;x +\u0026#34; + str(round(x*abs(slope), rounding)) + \u0026#34;))/2)\u0026#34;, end=\u0026#39;\u0026#39;) else: print (\u0026#34;- ((abs(\u0026#34; + str(round((slope), rounding)) + \u0026#34;x +\u0026#34; + str(round(-x2*(abs(slope)), rounding)) + \u0026#34;)-abs(\u0026#34; + str(round((slope), rounding)) + \u0026#34;x +\u0026#34; + str(round(-x*abs(slope), rounding)) + \u0026#34;))/2)\u0026#34;, end=\u0026#39;\u0026#39;) locations.clear() # Clear the list after calculation #Generate a smooth line going through the specified points def generate_smooth_line(): print(\u0026#34;WIP\u0026#34;) ##---------------------------------------------Execute Program---------------------------------------------## stopCommand = False #Repeat program until asked to stop while (not(stopCommand)): #Get mouse input mouse_input() #Sort points pixelList.sort() #Translate points to scaled cartesian coordinates finalList = translate_points(xScale, yScale, corner1, corner2) #Fix X coordinate repitition finalList = discontinuity_fix(finalList) #Output for i in finalList: print(i) print() output_abs_line(finalList) #Reset old pixel data pixelList = [] #Ask to stop stopCommand = (not(input(\u0026#34;\\nContinue? (y/n) \u0026#34;) == \u0026#34;y\u0026#34;)) Resulting Line Generation # With this program, I was able to successfully generate accurate lines to easily win graph war games that would have otherwise been almost impossible.\n","date":"25 June 2025","externalUrl":null,"permalink":"/projects/project-graphwar/","section":"Projects","summary":"Coded a python program to generate scaled piecewise equations that go through user-inputted click positions in the game Graph War.","title":"GraphWar Line Generation Program","type":"projects"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/tags/personal/","section":"Tags","summary":"","title":"Personal","type":"tags"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/tags/programming/","section":"Tags","summary":"","title":"Programming","type":"tags"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/categories/projects/","section":"Categories","summary":"","title":"Projects","type":"categories"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"25 June 2025","externalUrl":null,"permalink":"/","section":"WIMMEL Portfolio Website","summary":"","title":"WIMMEL Portfolio Website","type":"page"},{"content":"","date":"20 February 2025","externalUrl":null,"permalink":"/tags/engineering/","section":"Tags","summary":"","title":"Engineering","type":"tags"},{"content":" Extended summary # The original files I used were a mount for KSC75 2-pin mod and a snap in mount for mmcx mod. I merged these two because the former was designed to be screwed in, and I didn\u0026rsquo;t have access to screws at the time. I didn\u0026rsquo;t use the latter because I have heard bad things about the mmcx connector. After merging the models to optomize the characteristics I wanted, I made modifications to the design that would make soldering and mounting the 2-pin connector possible. Without these modifications, the connector was able to slide through completely, meaning the whole modification would implode if too much force was applied. After that, I modified everything fit correctly and made tweaks to better allow the ear clip from the original headphones to pivot. Finally, I printed the design and soldered it together. The soldering was the hardest part since the connectors had very small solder pads. The final 3D file can be found here.\n","date":"20 February 2025","externalUrl":null,"permalink":"/projects/project-ksc75-mod/","section":"Projects","summary":"Combined and modified various obj/stl files to quickly develop a functional mounting bracket for a female 2 pin jack. Soldered and glued the jack in for the complete functional mod.","title":"Small Project: KSC75 (Headphones) Detachable Cable Mod","type":"projects"},{"content":" Your browser doesn't support HTML5 video. Extended Summary # This was a high school project for the PLTW course, \u0026ldquo;Engineering Design and Development\u0026rdquo;. My peer, Aaron Kosoff, and I went through the entire design and development process. We started by researching a problem, examining its current solutions, and deciding on a final innovation that could improve upon current solutions. We landed on an adhesive-mounted door opening system controlled by various sensors and an arduino, as it would reduce costs by a few orders of magnitude while preventing 100% of pathogen spread. Through extensive prototyping, we landed on an acceptable rough design that met our design requirements.\nResearch # Problems # The design process began with researching problems. We had a few different ideas, but settled on pathogen spread through door handles because we had found a good amount of research showing that it was a significant problem.\nPrevious Solutions # This led to us looking into previous solutions and comparing them in a table. The graded overall best solutions we found were automatic doors and a door stop, since they prevent contact with the door completely. The door stop\u0026rsquo;s main problem was that it removes the security and insulation that a door provides, while the automatic door was found to be overly expensive ($10k+). Because of this, we knew we had to create something that made doors touch-free at a low cost.\nBrainstorming # We came up with a number of possible solutions to the problem. One solution was an automatic door that could be mounted above an empty doorframe, behaving like a garage door. We decided this would be too impractical for use. Another idea was a door handle that heated up to kill bacteria. This idea was shot down because of obvious safety concerns. Finally, we came to the idea of a system that you could mount to any door to make it an automatic door. This idea seemed affordable, safe, and preserved the insulation and security of the original door.\nElectronics Prototyping # After our initial sketches of the system, we came up with an electrical system that would work to open the most doors. We determined that we would need a powerful motor to open the door (we calculated the force and leverage but i don\u0026rsquo;t have access to my old notes right now), a servo to turn the handle to a specified angle, a motion sensor to detect movement, and a distance sensor to keep the system from hitting people and walls while opening the door.\nMechanics Prototyping # Using our initial sketches, we made a rough prototype to test the feasability of pulling the whole door with adhesive strips and a small motor. This confirmed that our mounting solution was valid, and that the motor was powerful enough when given the correct voltage.\nOur second prototype was 3d printed and used an aluminum wheel with a rubber grip so that the shaft wouldn\u0026rsquo;t shred the inside of the wheel, and the wheel could grip the ground. This didn\u0026rsquo;t work so well because the wheel didn\u0026rsquo;t have enough traction. We calculated the force we would need to put on the ground given the friction coefficient of the wheel. Instead of considering this, we decided to test various springs to impart ground force, using the one that worked most effectively.\nAfter that, we went through various mechanical prototypes. Between these prototypes, we added/adjusted mounting points for the various sensors. We also slowly built in spaces for the arduino, motor controller, and battery to fit. Eventually we came to a final design that had mounting points for everything and a shroud to cover all of the internal wiring. This design was functional, but not exactly production ready as the shroud was simply slipped on, and not locked on like a public facility would need.\nBelow shows, in order, a front view of mount with components, a top right view of mount structure, and a top right view of mount with components. Shroud model was excluded from these images.\nCode Prototyping # We started with a basic pseudocode framework that looked something like this:\nLoop forever{ If motion sensor activated: Turn door handle servo Motor forwards Loop until distance sensor is too close{ Wait a short time } Wait for someone to walk through the door Motor backwards for the time it took to open Return Door handle servo Else: Wait a short time } We researched how to use C++ to recieve and send signals through an Arduino. Through a few iterations, and using the pseudocode as a guide, we eventually developed the following code.\nCode #include \u0026lt;Servo.h\u0026gt; // Define pin numbers for input and output int motionSensorPin = 5; int servoPin = 2; int distanceSensorPin = A0; int in1Pin = 8; int in2Pin = 9; int enaPin = 10; // Define variables int motionDetected = 0; int distance = 0; int motorSpeed = 255; int timeVariable = 10; // Create objects Servo myservo; void setup() { Serial.begin(9600); // Attach servo to pin myservo.attach(servoPin); // Set motor control pins to outputs pinMode(in1Pin, OUTPUT); pinMode(in2Pin, OUTPUT); pinMode(enaPin, OUTPUT); //Set motion sensor pin to input pinMode(motionSensorPin, INPUT); // Set initial motor speed to zero analogWrite(enaPin, 0); } void loop() { // Read and print motion sensor input int motionDetected = digitalRead(motionSensorPin); Serial.println(motionDetected); delay (500); // Read and print distance sensor input distance = analogRead(distanceSensorPin); Serial.println(distance); delay (500); //Run the following if motion is detected by the motion sensor (HIGH) if (motionDetected == HIGH) { //Make the servo go down, and wait 300 ms before beginning the first motor event myservo.write(-135); Serial.println(\u0026#34;Servo Down\u0026#34;); delay (300); Serial.println(\u0026#34;Motor Forward\u0026#34;); //Run motor forward until the distance is greater than 300, checking distance every 500 ms and storing how much //time it has been running while (distance \u0026lt; 300){ digitalWrite(in1Pin, HIGH); digitalWrite(in2Pin, LOW); digitalWrite(enaPin, HIGH); distance = analogRead(distanceSensorPin); timeVariable = timeVariable + 500; delay(500); Serial.println(distance); } //Stop motor for the amount of time that it took to complete the first cluster Serial.println(\u0026#34;Motor Stop\u0026#34;); Serial.println(timeVariable); digitalWrite(in1Pin, LOW); digitalWrite(in2Pin, LOW); digitalWrite(enaPin, LOW); delay(timeVariable); //Run motor backwards for the amount of time that it took to complete the first cluster Serial.println(\u0026#34;Motor Backwards\u0026#34;); Serial.println(timeVariable); digitalWrite(in1Pin, LOW); digitalWrite(in2Pin, HIGH); digitalWrite(enaPin, HIGH); delay (timeVariable); //reset timevariable for next cycle timeVariable = 10; //if there is no motion detected, make the servo go up, stop the motor, and wait 500ms before checking the //state of the motion sensor again } else { Serial.println(\u0026#34;Servo Up, Motor Stop\u0026#34;); myservo.write(135); digitalWrite(in1Pin, LOW); digitalWrite(in2Pin, LOW); digitalWrite(enaPin, LOW); delay (500); } } Presentation # Finally, we presented our project at a public school exhibition with industry experts that were asked to come rate us. Our teacher, Ms. Mason, then asked us and one other group whether we\u0026rsquo;d like to present our projects to the Cotati-Rohnert Park District School Board to show how Engineering Design and Development was a worthwhile course to continue teaching in the school district. We accepted, and presented our project there as well.\nReflection # In conclusion, this was a fun and successful project. I thoroughly enjoyed the design process and getting to make something that could actually benefit people in the real world. This project exercised and improved my teamwork, presentation, CAD, coding, and electrical systems design skills all while allowing me to make something, which was really awesome.\n","date":"22 September 2023","externalUrl":null,"permalink":"/projects/project-autodoor/","section":"Projects","summary":"Collaborated with one of my peers to design and develop a sensor/arduino controlled automatic door system, reducing costs 90% compared to industry standards.","title":"Automatic Door Opening System","type":"projects"},{"content":"","date":"22 September 2023","externalUrl":null,"permalink":"/tags/school/","section":"Tags","summary":"","title":"School","type":"tags"},{"content":"","date":"13 June 2022","externalUrl":null,"permalink":"/projects/","section":"Projects","summary":"","title":"Projects","type":"projects"},{"content":" Extended Summary # The original files I used were a high poly moai stone model, a low poly moai stone model, and a generic keycap model I found. I combined all of them in tinkercad by hollowing out the moai and placing the keycap stem in the middle. I had to adjust tolerances, scale things, and reshape everything a few times to get 3d prints of the file to fit correctly on a standard keyboard. The final product is here, with a few versions that work on different types of keyboards.\n","date":"16 December 2021","externalUrl":null,"permalink":"/projects/project-moaikey/","section":"Projects","summary":"Combined and modified various obj/stl files to quickly develop functional 3D-printed moai keycaps with acceptable fitment and strength.","title":"Small Project: Moai Keycaps","type":"projects"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]